\chapter{Taint Analysis for Member Variables (WORK IN PROGRESS)}
\label{field-tainting}

This chapter describes a concept for adding taint analysis for member variables of objects to Pixy---the 2007 release of Pixy explicitly mentions this as a ``missing feature''.

\section{Modeling Member Variables as Places for Three-Address Code (TAC)}
\index{member variables}\index{fields}\index{three-address code}

Pixy models variables as ``places'' for three-address code (see section~\ref{tac} on page~\pageref{tac} for details). For taint analysis, it uses this ``place'' abstraction---instead of the variable directly from the parse tree---to model the flow of data through the program.

Hence, we need a way to convert access to member variables from the PHP parse tree into TAC places. This needs to happen within the \texttt{TacConverter} class which is responsible for the task of creating both the control-flow graph as well as the three-address code from the PHP parse tree.


\subsection{Creating Symbol Table Entries for Objects}

\subsubsection{Class Declaration}

For the following code for declaring a class with one field, the corresponding subtree of the PHP parse tree is depicted in figure~\ref{fig:parse-tree-foo-class} on page~\pageref{fig:parse-tree-foo-class}.

\begin{phpcode}
class Foo {
  var $field = 42;
}
\end{phpcode}

Note: This piece of code still uses the PHP~4 way of declaring member variables. Using the PHP~5 way with access keywords like \texttt{public}, \texttt{protected} or \texttt{private} would work correspondingly.

\begin{figure}[htb]
  \begin{center}
    \includegraphics[scale=0.5]{images/parsetree-foo-class-declaration}
   \caption{The subtree of the PHP parse tree for declaring a class \texttt{Foo} with a single field \texttt{\$field} that has a default value of \texttt{42}.}
   \label{fig:parse-tree-foo-class}
  \end{center}
\end{figure}

At the point where the \texttt{TacConverter} class encounters the class definition, it would be neither necessary nor helpful to save the taint state\footnote{See section~\ref{taint-state} on page~\pageref{taint-state} for details.} of the fields for new class instances: Member variables that have not been written yet by any code can always be considered untainted as the PHP interpreter only allows literals as default values, and Pixy always assumes literals to be untainted. Furthermore, uninitialized \emph{member variables} cannot be overwritten using request parameters even if \texttt{register\_globals}\index{register\_globals} is enabled. This is different to the way PHP handles uninitialized local or global variables (see section~\ref{register-globals}).

In addition, the list of declared fields might be only a subset of the fields that are actually accessed in the code: If the PHP interpreter finds a read or write access to an undeclared field, it creates this field for that particular instance on the fly, initializes it with \texttt{null}, and issues a PHP strict warning.


\subsubsection{Class Instantiation}

In the following code example, class declared above gets instantiated in the \texttt{\$foo} variable. The corresponding subtree of the PHP parse tree looks like figure~\ref{fig:parse-tree-new-foo} on page~\pageref{fig:parse-tree-new-foo}.

\begin{phpcode}
$foo = new Foo();
\end{phpcode}

\begin{figure}[htb]
  \begin{center}
    \includegraphics[scale=0.5]{images/parsetree-new-foo}
   \caption{The subtree of the PHP parse tree for creating an instance \texttt{\$foo} of the class \texttt{Foo}.}
   \label{fig:parse-tree-new-foo}
  \end{center}
\end{figure}

Currently, the \texttt{TacConverter} already adds a \texttt{Variable} entry into the current function's symbol table. To closely model the way PHP stores object instances with a separate symbol table per instance (see section~\ref{php-variables} on page~\pageref{php-variables}~ff.), we need a subclass \texttt{ObjectVariable extends Object} that holds a reference to a symbol table instance.

In pseudo-code, processing this assignment would look like this:

\begin{textcode}
AbstractPlace expr_without_variable(subtree) {
  // Extract children from subtree here.

  if (secondChild == T_ASSIGN) {
    assign(subtree);
    return null;
  }

  if (firstChild == T_NEW) {
    return new ObjectVariable();
  }

  // More existing code for processing variables and literals.
}

assign(subTree) {
  variableName = getVariableNameFromLeftSubtree(subtree);
  rightPlace = expr_without_variable(subTree->rightChild->firstChild);
  addVariableToSymbolTable(variableName, rightPlace);
}
\end{textcode}

\paragraph{Note:} In the \texttt{TacConverter} class, the functions are named after the opcodes in the PHP parse tree. The function \texttt{expr\_without\_variable} is called twice because is occurs twice in the subtree (see figure~\ref{fig:parse-tree-new-foo} on page~\pageref{fig:parse-tree-new-foo}).

For the sake of brevity, this pseudo-code omits the part about creating temporary variables if a variable already is present in the symbol table. This feature already exists in Pixy and does not need to be changed.


\subsubsection{Field Access}

To track tainting for member variables, Pixy needs to create ``places'' for all member variables that are accessed---even for those that have not been declared beforehand. (PHP will happily create it on the fly while issuing a PHP warning.)

Both for the left side of assignments as well as for all expressions, we need to add a way to handle field access as places. In addition to the already existing cases (\eg function calls, literals, normal variables etc.), the following cases are new and need to be modeled:

\myTable{
\begin{tabular}{|l|l|l|}
\hline
\bb{case description} & \bb{example} & \bb{parse tree figure} \\
\hline
  simple variable assignment & \texttt{\$x = 42;}  & \ref{fig:simple-variable-assignment} on page~\pageref{fig:simple-variable-assignment} \\
  (already part of Pixy) & & \\
\hline
  one-level field access (left side) & \texttt{\$foo->bar = 42;} & \ref{fig:one-level-field-access-left} on page~\pageref{fig:one-level-field-access-left} \\
\hline
  one-level field access (right side) & \texttt{\$x = \$foo->bar;} & \ref{fig:one-level-field-access-right} on page~\pageref{fig:one-level-field-access-right} \\
\hline
  multi-level field access (left side) & \texttt{\$foo->bar->baz = 42;} & \ref{fig:multi-level-field-access-left} on page~\pageref{fig:multi-level-field-access-left} \\
\hline
  multi-level field access (right side) & \texttt{\$x = \$foo->bar->baz;} & \ref{fig:multi-level-field-access-right} on page~\pageref{fig:multi-level-field-access-right} \\
\hline
  variable field access (left side) & \texttt{\$foo->\$fieldName = 42;} & \ref{fig:variable-field-access-left} on page~\pageref{fig:variable-field-access-left} \\
\hline
  variable field access (right side) & \texttt{\$x = \$foo->\$fieldName;} & \ref{fig:variable-field-access-right} on page~\pageref{fig:variable-field-access-right} \\
\hline
\end{tabular}
}{Field accesses that need to be modeled}{table:field-access-cases}

\paragraph{Note:} Method chaining in PHP is possible, as is field access chaining. After field chaining, method calls are possible. However, even if a method returns an object, chained field accesses on that object are not possible. This approach does not cover method call after field accesses as Pixy already is quite versed at finding out which method from which class gets called.


\begin{figure}[htb]
  \begin{center}
    \includegraphics[trim = 30mm 0mm 50mm 10mm, scale=0.8]{images/simple-variable-assignment}
   \caption{The PHP parse subtree of \texttt{\$x = 42;}}
   \label{fig:simple-variable-assignment}
  \end{center}
\end{figure}

\begin{figure}[htb]
  \begin{center}
    \includegraphics[trim = 60mm 0mm 0mm 20mm, scale=0.8]{images/one-level-field-access-left}
   \caption{The PHP parse subtree of \texttt{\$foo->bar = 42;}}
   \label{fig:one-level-field-access-left}
  \end{center}
\end{figure}

\begin{figure}[htb]
  \begin{center}
    \includegraphics[trim = 40mm 0mm 0mm 10mm, scale=0.9]{images/one-level-field-access-right}
   \caption{The PHP parse subtree of \texttt{\$x = \$foo->bar;}}
   \label{fig:one-level-field-access-right}
  \end{center}
\end{figure}

\begin{figure}[htb]
  \begin{center}
    \includegraphics[trim = 50mm 0mm 0mm 25mm, scale=0.75]{images/multi-level-field-access-left}
   \caption{The PHP parse subtree of \texttt{\$foo->bar->baz = 42;}}
   \label{fig:multi-level-field-access-left}
  \end{center}
\end{figure}

\begin{figure}[htb]
  \begin{center}
    \includegraphics[trim = 30mm 0mm 0mm 20mm, scale=0.8]{images/multi-level-field-access-right}
   \caption{The PHP parse subtree of \texttt{\$x = \$foo->bar->baz;}}
   \label{fig:multi-level-field-access-right}
  \end{center}
\end{figure}

\begin{figure}[htb]
  \begin{center}
    \includegraphics[trim = 60mm 0mm 0mm 10mm, scale=0.8]{images/variable-field-access-left}
   \caption{The PHP parse subtree of \texttt{\$foo->\$fieldName = 42;}.}
   \label{fig:variable-field-access-left}
  \end{center}
\end{figure}

\begin{figure}[htb]
  \begin{center}
    \includegraphics[trim = 40mm 0mm 0mm 20mm, scale=0.8]{images/variable-field-access-right}
   \caption{The PHP parse subtree of \texttt{\$x = \$foo->\$fieldName;}.}
   \label{fig:variable-field-access-right}
  \end{center}
\end{figure}

As Pixy currently does not model the---relatively rare---case of variable variables, this approach does not model them on the field level either. Instead, this approach uses Pixy's special place \emph{specialPlaceForVariableVariables} that keeps this place out of taint analysis.

Looking at the big picture, both for left-side and right-side expressions, the \texttt{TacConverter} walks the field access chain to the end, using existing fields in the object's symbol tables or creating new ones as needed. There are two basic cases we need to cover: a write access to a place, \ie an assignment, and a read access---be it as the right part of an assignment, as part of a compound expression or as a parameter in a function call. In each and every case, the parse tree for the variable expression has a \texttt{cvar} node in it. So this approach expands the \texttt{cvar} function to also return places for field accesses.

\paragraph{Note:} The listed pseudo-code takes a few shortcuts: It assumes that there are some convenience functions available for tree walking, array processing and string processing, and that functions like \texttt{cvar} return \texttt{AbstractPlace} instead of a \texttt{TacAttributes} wrapper.

\begin{textcode}
/**
 * Returns the AbstractPlace that corresponds to a cvar node in the
 * parse tree.
 */
AbstractPlace cvar(
  ParseNode subtreeRoot, SymbolTable functionSymbolTable
) {
  String[] nameChain = flattenCvarTreeToNameChain(subtreeRoot);

  return getLeftPlaceForNameChain(nameChain, functionSymbolTable);
}
\end{textcode}

\begin{textcode}
/**
 * Walks a cvar parse node subtree and extracts the variable name
 * or chained field names from it. The dollar sign from the first
 * variable is omitted.
 *
 * For example, for a variable $foo, this function returns:
 * ["foo"]
 *
 * For a variable $foo->bar->$baz, this function returns:
 * ["foo", "bar", "$baz"]
 */
String[] flattenCvarTreeToNameChain(ParseNode subtreeRoot) {
  String[] nameChain;

  for (ParseNode node : subTreeRoot.depthFirstIterator()) {
    Token token = node.token;
    if (!(token != T_VARIABLE && token != T_STRING) {
      continue;
    }

    // Drop the first dollar sign.
    if (nameChain.length == 0) {
      nameChain.append(node.text.dropFirstCharacter);
    } else {
      nameChain.append(node.text);
    }
  }

  return nameChain;
}
\end{textcode}

\begin{textcode}
/**
 * Gets the AbstractPlace for a variable name chain from symbolTable.
 *
 * If there is no place with that name yet, it will be created on the
 * fly (if possible).
 */
AbstractPlace getLeftPlaceForNameChain(
  String[] nameChain, SymbolTable symbolTable
) {
  String firstElementInNameChain = nameChain[0];
  if (isVariableVariable(firstElementInNameChain)) {
    return specialPlaceForVariableVariables;
  }

  if (nameChain.length == 1) {
    return getOrCreateVariableInSymbolTable(
      firstElementInNameChain. symbolTable
    );
  }

  // At this point, we have more than one element in the name chain,
  // i.e., a field access.
  if (!symbolTable.has(firstElementInNameChain)) {
    throw new Exception("Field access on nonexistent object.");
  }

  AbstractPlace firstPlaceFromNameChain = symbolTable.getByName(
    firstElementInNameChain
  );
  if (!firstPlaceFromNameChain instanceof ObjectVariable) {
    throw new Exception("Field access on non-object variable.");
  }

  String[] nameChainWithoutFirstElement = nameChain.dropFirst();
  return getLeftPlaceForNameChain(
    nameChainWithoutFirstElement,
    ((ObjectVariable) firstPlaceFromNameChain).symbolTable
  );
}
\end{textcode}

\begin{textcode}
/**
 * Retrieves the Variable stored under the given variableName from
 * the symbolTable.
 *
 * If there is no entry for that variableName yet, creates a new
 * Variable entry, stores it in the symbolTable and returns it.
 */
Variable getOrCreateVariableInSymbolTable(
  String variableName, SymbolTable symbolTable
) {
  if (symbolTable.has(variableName)) {
    return symbolTable.getByName(variableName))
  }

  Variable newVariable = new Variable();
  symbolTable.addByName(variableName, newVariable);

  return newVariable;
}
\end{textcode}

\chapter{Alias analysis}

When performing static code analysis, a good alias analysis is helpful as it can both increase recall and precision. A good recall is important as it will allow Pixy to find more vulnerabilities. A good recall is important to reduce noise, thus making the results more meaningful for the developers: If there are too many meaningless warnings, developers just tend to ignore them (or stop using the tool).~\cite{understanding-value}

For understanding the intricacies of alias analysis for PHP, it is important to first have a firm grip on the way references work in PHP (which is quite different from the way aliases work e.\,g., in C or Java). Thus a big part of the exiting work on alias analysis does not directly apply to PHP.~\cite[page~24]{pixy} Subsection~\ref{sec:references} on page~\pageref{sec:references} provides more information on this.

\section{Alias analysis in Pixy}

For its alias analysis, Pixy uses a modified version of the points-to-analysis described by Khedker et.\,al~\cite[page 119ff]{data-flow-analysis}, including the concept of ``must'' and ``may'' aliases.

\paragraph{Must-aliases} are relationships between variables that are aliases to the same ZVAL independent of the actual executed program path.

\paragraph{May-aliases} are relationships between variables that are aliases only for some executed program paths.

This separation helps in cases where two variables \texttt{\$a} and \texttt{\$b} are tainted and \texttt{\$a} gets sanitized. If \texttt{\$a} and \texttt{\$b} are must-aliases, \texttt{\$b} can safely considered to be sanitized as well. However, if both variables are may-aliases, the scanner should make a conservative decision and consider \texttt{\$b} still to be tainted.


\subsection{Intraprocedural alias analysis}

This section describes how Pixy conducts alias analysis within a function or method (as explained in~\cite{pixy}).

Pixy keeps record for all must-aliases and may-aliases for each line of program code. The must-aliases are represented as unordered and disjoint sets of variables that are certain to be references to the same ZVAL at a certain point at the program. May-aliases are represented the same way. Let's have a look at an example.

Note: In these examples, the sets of must-aliases and may-aliases always refer to point of execution after the last code line listed above.

At the beginning of a function or method, the sets of may-aliases and must-aliases is empty:

$mustAliases = \{\}, mayAliases = \{\}$

When a reference is created, the pair of both variables is added to the must-aliases:

\begin{phpcode}
$a = &$b;
\end{phpcode}
$mustAliases = \{(a, b)\}, mayAliases = \{\}$


If there is a branch condition, the aliases set within the branch still are considered to be must-aliases, but \emph{only within that particular branch}.

\begin{phpcode}
$a = &$b;
if (...) {
  $c = &$d;
\end{phpcode}
$mustAliases = \{(a, b), (c, d)\}, mayAliases = \{\}$

\begin{phpcode}
$a = &$b;
if (...) {
  $c = &$d;
  $e = &$d;
\end{phpcode}
$mustAliases = \{(a, b), (c, d, e)\}, mayAliases = \{\}$

Now, after the branch, the scanner needs to change the must-aliases that have been created during the branch to may-aliases (as it is not safe to assume that the branch will be executed in each and every case):

\begin{phpcode}
$a = &$b;
if (...) {
  $c = &$d;
  $e = &$d;
}
\end{phpcode}
$mustAliases = \{(a, b)\}, mayAliases = \{(c, d, e\}$

To ease processing, the alias tuples with more than two elements are split into separate pairs:

$mustAliases = \{(a, b)\}, mayAliases = \{(c, d), (c, e), (d, e)\}$


\subsection{Interprocedural alias analysis}

This section describes how Pixy conducts alias analysis between functions or methods (as explained in~\cite{pixy}).

Generally, there are two possible scopes for variables in PHP: local variables and global variables. (Please see section \ref{sec:variable-scope} on page \pageref{sec:variable-scope} for details.)

Hence, at the point of a function call, the alias analysis needs to track both alias information that gets propagated into the function, and alias information that is valid when the control flow returns from the function.

So, from the called function's point of view (i.e., from the callee's point of view), the following information is important when the function gets called:

\begin{itemize}
  \item aliases between global variables
  \item aliases between the method parameters
  \item aliases between global variables and the method parameters
\end{itemize}

After control flow has been returned from a method, the following alias information needs to be obtained (or updated):

\begin{itemize}
  \item aliases between global variables
  \item aliases between global variables and the caller's local variables
\end{itemize}


\subsubsection{Aliases between global variables}

For tracking global variables, the notation of must-aliases and may-aliases is changed so that there is an optional method name prefix for the variable name. For the global symbol table, we use a ``special'' function ``m'' (for ``main'').

Let have an example:

At the beginning, there are not must-aliases or may-aliases:

$mustAliases = \{\}, mayAliases = \{\}$




\section{Alias analysis for the default pass-by-reference in PHP 5}

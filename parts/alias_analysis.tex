\chapter{Alias Analysis (WORK IN PROGRESS)}

When performing static code analysis, a good alias analysis is helpful as it can both increase recall and precision. A good recall is important as it will allow Pixy to find more vulnerabilities. A good recall is important to reduce noise, thus making the results more meaningful for the developers: If there are too many meaningless warnings, developers just tend to ignore them---or stop using the tool.~\cite{understanding-value}

For understanding the intricacies of alias analysis for PHP, it is important to first have a firm grip on the way references work in PHP (which is quite different from the way aliases work e.\,g., in C or Java). Thus, a big part of the exiting work on alias analysis does not directly apply to PHP.~\cite[page~24]{pixy} Subsection~\ref{sec:references} on page~\pageref{sec:references} provides more information on this.

\section{Alias Analysis in Pixy}

For its alias analysis, Pixy uses a modified version of the points-to-analysis described by Khedker et.\,al~\cite[page 119ff]{data-flow-analysis}, including the concept of ``must'' and ``may'' aliases.

\paragraph{Must-aliases} are relationships between variables that are aliases to the same ZVAL independent of the actual executed program path.
\index{must-alias}\index{alias!must-|see{must-alias}}

\paragraph{May-aliases} are relationships between variables that are aliases only for some executed program paths.
\index{may-alias}\index{alias!may-|see{may-alias}}

This separation helps in cases where two variables \texttt{\$a} and \texttt{\$b} are tainted and \texttt{\$a} gets sanitized. If \texttt{\$a} and \texttt{\$b} are must-aliases, \texttt{\$b} can safely be marked to be sanitized as well. However, if both variables are may-aliases, the scanner should make a conservative decision and regard \texttt{\$b} as still to be tainted.

This concept comes into use both for intraprocedural as well as interprocedural alias analysis.


\subsection{Intraprocedural Alias Analysis (READ FOR FEEDBACK, PROOFREAD)}
\label{sec:intraprocedural-alias-analysis}\index{alias analysis!intraprocedural}\index{intraprocedural alias analysis|see{alias analysis, intraprocedural}}

This section describes how Pixy conducts alias analysis within a function or method (as explained in~\cite{pixy}).

Pixy keeps record for all must-aliases and may-aliases for each line of program code. The must-aliases are represented as unordered and disjoint sets of variables that are certain to be references to the same ZVAL at a certain point at the program. May-aliases are represented the same way. Let's have a look at an example.

Note: In these examples, the sets of must-aliases and may-aliases always refer to point of execution after the last code line listed above.

At the beginning of a function or method, the sets of may-aliases and must-aliases are empty:

$mustAliases = \{\}, mayAliases = \{\}$

When a reference is created, the pair of both variables is added to the must-aliases:

\begin{phpcode}
$a = &$b;
\end{phpcode}
$mustAliases = \{(a, b)\}, mayAliases = \{\}$


If there is a branch condition, the aliases set within the branch still are considered to be must-aliases, but \emph{only within that particular branch}.

\begin{phpcode}
$a = &$b;
if (...) {
  $c = &$d;
\end{phpcode}
$mustAliases = \{(a, b), (c, d)\}, mayAliases = \{\}$

\begin{phpcode}
$a = &$b;
if (...) {
  $c = &$d;
  $e = &$d;
\end{phpcode}
$mustAliases = \{(a, b), (c, d, e)\}, mayAliases = \{\}$

Now, after the branch, the scanner needs to change the must-aliases that have been created during the branch to may-aliases---for it is not safe to assume that the branch will be executed in each and every case:

\begin{phpcode}
$a = &$b;
if (...) {
  $c = &$d;
  $e = &$d;
}
\end{phpcode}
$mustAliases = \{(a, b)\}, mayAliases = \{(c, d, e\}$

To ease processing, the alias tuples with more than two elements are split into separate pairs:

$mustAliases = \{(a, b)\}, mayAliases = \{(c, d), (c, e), (d, e)\}$


\subsection{Interprocedural Alias Analysis (READ FOR FEEDBACK, PROOFREAD)}
\label{sec:interprocedural-alias-analysis}\index{alias analysis!interprocedural}\index{interprocedural alias analysis|see{alias analysis, interprocedural}}

This section describes how Pixy conducts alias analysis between functions or methods (as explained in~\cite{pixy}).

Generally, there are two possible scopes for variables in PHP: local variables and global variables. (Please see section \ref{sec:variable-scope} on page \pageref{sec:variable-scope} for details.)

Hence, at the point of a function call, the alias analysis needs to track both alias information that gets propagated into the function, and alias information that is valid when the control flow returns from the function.

Thus, from the called function's (the callee's) point of view, the following information is important when the function gets called:

\begin{itemize}
  \item aliases between global variables
  \item aliases between the method parameters
  \item aliases between global variables and the method parameters
\end{itemize}

After control flow has been returned from a method, the following alias information needs to be obtained (or updated):

\begin{itemize}
  \item aliases between global variables
  \item aliases between global variables and the caller's local variables
\end{itemize}


\subsubsection{Aliases Between Global Variables}
\label{sec:aliases-globals}\index{aliases between global variables}\index{global variables}

For tracking global variables, the notation of must-aliases and may-aliases is changed by adding a method name prefix to the variable name. For the global symbol table, Pixy uses a ``special'' function \texttt{m} (for \texttt{main}).

Let's have an example:

At the beginning, there are no must-aliases or may-aliases. This information (particularly, the information on the global aliases) then gets propagated into the function:

\begin{phpcode}
foo();

function foo() {
\end{phpcode}

$mustAliases = \{\}, mayAliases = \{\}$

\begin{phpcode}
foo();

function foo() {
  $a1 = 42;
  $a2 = &$a1;

  $GLOBALS['x2'] = &$GLOBALS['x1'];
\end{phpcode}

$mustAliases = \{(foo.a1, foo.a2), (m.x1, m.x2)\}, mayAliases = \{\}$

At this point of the control flow within the function, the local variables \texttt{\$a1} and \texttt{\$a2} are must-aliases to each other---as are the global variables \texttt{\$x1} and \texttt{\$x2}. This is just applying the intraprocedural techniques described in section~\ref{sec:intraprocedural-alias-analysis}.

Now, when the function \texttt{foo} calls another function \texttt{bar}, only alias information on global variables is propagated into \texttt{bar} (as there are not parameters):

\begin{phpcode}
foo();

function foo() {
  $a1 = 42;
  $a2 = &$a1;

  $GLOBALS['x2'] = &$GLOBALS['x1'];
  bar();
  ...
}

function bar() {
\end{phpcode}

$mustAliases = \{(m.x1, m.x2)\}, mayAliases = \{\}$

If \texttt{bar} adds aliases on global variables, these get added to the must-aliases (as seen from the perspective of still within \texttt{bar}):

\begin{phpcode}
foo();

function foo() {
  $a1 = 42;
  $a2 = &$a1;

  $GLOBALS['x2'] = &$GLOBALS['x1'];
  bar();
  ...
}

function bar() {
  $GLOBALS['x3'] = &$GLOBALS['x1'];
\end{phpcode}

$mustAliases = \{(m.x1, m.x2, m.x3)\}, mayAliases = \{\}$

After the control flow is back from \texttt{bar} in \texttt{foo}, the changed information on global aliases is available within \texttt{foo} as well (in addition to the alias information on the local variables):

\begin{phpcode}
foo();

function foo() {
  $a1 = 42;
  $a2 = &$a1;

  $GLOBALS['x2'] = &$GLOBALS['x1'];
  bar();
\end{phpcode}

$mustAliases = \{(foo.a1, foo.a2), (m.x1, m.x2, m.x3)\}, mayAliases = \{\}$


\subsubsection{Aliases Between Function Parameters Passed by Reference}

By default, PHP passes function parameters by value. However, it also is possible to have function parameters passed by referenced by using an ampersand in the function declaration. These cases are relevant for the alias analysis.

When the callee has two parameters that are passed by reference, and the caller passes two variables that are aliases, the alias analysis needs to propagate this information into the callee.

Let's have a look an an example:

\begin{phpcode}
function foo() {
  $a1 = 42;
  $a2 = &$a1;

  bar($a1, $a2);
  ...
}

function bar(&$b1, &$b2) {
\end{phpcode}

At the point where \texttt{bar} is called, the alias information looks like this in the \texttt{foo} function:

$mustAliases = \{(foo.a1, foo.a2)\}, mayAliases = \{\}$

Within the \texttt{bar} function, the propagated alias information thus consists of the parameters as must-aliases:

$mustAliases = \{(bar.b1, bar.b2)\}, mayAliases = \{\}$


If the parameters that are passed are may-aliases, they correspondingly get propagated as may-aliases:

\begin{phpcode}
function foo() {
  $a1 = 42;
  $a2 = 8;

  if (...) {
    $a2 = &$a1;
  }

  bar($a1, $a2);
  ...
}

function bar(&$b1, &$b2) {
\end{phpcode}

At the point where \texttt{bar} is called, the alias information looks like this in the \texttt{foo} function:

$mustAliases = \{\}, mayAliases = \{(foo.a1, foo.a2)\}$

And this is the alias information at the beginning of the \texttt{bar} function:

$mustAliases = \{\}, mayAliases = \{(bar.b1, bar.b2)\}$



\subsubsection{Aliases Between Global Variables and Parameters Passed by Reference}

As far as global variables are concerned, there are basically three cases to be considered for pass-by-reference parameters:

\begin{itemize}
  \item The paramater is a global variable (and thus also a trivial must-alias of a global variable).
  \item The parameter is a must-alias of a global variable.
  \item The parameter is a may-alias of a global variable.
\end{itemize}

In all three cases, the parameter gets propagated as the corresponding type of must-alias or may-alias to the global variable into the function:

\begin{phpcode}
function foo() {
  $a1 = $GLOBALS['a1'];
  $a2 = 8;

  if (...) {
    $a2 = $GLOBALS['a2'];
  }

  bar($a1, $a2, $GLOBALS['a3']);
  ...
}

function bar(&$b1, &$b2, &$b3) {
\end{phpcode}

At the point where \texttt{bar} is called, the alias information looks like this in the \texttt{foo} function (again using the \texttt{m} function as a fake scope for global variables):

$mustAliases = \{(foo.a1, m.a1)\}, mayAliases = \{(foo.a2, m.a2)\}$

And this is the alias information at the beginning of the \texttt{bar} function:

$mustAliases = \{(bar.b1, m.a1), (bar.b3, m.a3)\}, mayAliases = \{(bar.b2, m.a2)\}$





\section{Alias Analysis for the Default Pass-by-Reference in PHP~5}

\chapter{Review of Existing Static PHP Vulnerability Scanners (READY FOR FEEDBACK, partly PROOFREAD)}
\label{scanners}

For this thesis, an existing scanner was needed that already worked reasonably well and could be modified (\ie it needed to be under an Open Source license like the Gnu Public License).



\section{SWAAT}
\label{swaat}\index{SWAAT}
SWAAT~\cite{swaat} is closed-source freeware or open source (depending on whether the enclosed FAQ file or the web site should be considered the more current source), programmed in .NET. It solely relies on string matching. On the test suite, it listed practically all SQL queries as ``security sensitive functionality'', recommending ``manual source code review''. Effectively, it produced many false positive and did not find any of the existing XSS issues.

This project has been orphaned, \ie development and maintenance have ceased.

\section{CodeSecure Verifier}
\label{armorize}\index{Code Secure Verifier}\index{Armorize Code Secure Verifier}
Armorize CodeSecure Verifier~\cite{codesecure, verifier} is a closed-source, commercial source code scanner that is available in hardware and as software-as-a-service (SaaS). It provides data-flow and control-flow analysis, thus detecting most tainted-object-propagation vulnerabilities.

This scanner is based on the research published in \cite{huang-securing}.

\section{PHP-SAT}
\label{php-sat}\index{PHP-SAT}
PHP-SAT~\cite{php-sat} is an Open Source tool programmed in Stratego/XT~\cite{stratego} that uses intraprocedural data-flow analysis. It is based on PHP-front~\cite{php-front} and is able to work on code written in PHP~4 and 5. There is no stable release yet, and development has ceased in 2007.

This tool does not compile on the used testing environment Ubuntu, and has very scarce documentation.

\section{Pixy}
\label{pixy-comparison}\index{Pixy}
Pixy~\cite{pixy} is an Open Source tool programmed in Java using interprocedural data-flow analysis.

Pixy currently works only on PHP 4 code. After changing the test suite to PHP 4-only, Pixy found all vulnerabilities that did not use PHP~5 autoloading.

\section{Yasca---Yet Another Source Code Analyzer}
\label{yasca}\index{Yasca}
Yasca~\cite{yasca} is an Open Source tool programmed in PHP that combines its own pattern-matching search with the output of other scanners included as plug-ins, among them Pixy and PHPlint.

Using only its own scanning engine, Yasca was not able to find a single vulnerability.


\section{Deciding on a Scanner for the Thesis}

This is an overview of the desired properties for a scanner which could be used as a basis for the thesis:

\myTable{
\begin{tabular}{|l|l|l|l|l|}
\hline
 & \bb{Open Source} & \bb{runs at all} & \bb{good recall} & \bb{good precision} \\
\hline
SWAAT & (unclear) & \checkmark & --- & --- \\
\hline
Code Secure Verifier & --- & (\checkmark) & (not tested) & (not tested) \\
\hline
PHP-SAT & \checkmark & --- & (not tested) & (not tested) \\
\hline
Pixy & \checkmark & \checkmark & \checkmark & \checkmark   \\
\hline
Yasca & \checkmark & \checkmark & --- & (nothing found) \\
\hline
\end{tabular}
}{Reviewed PHP security scanners}{scanners-overview}

Pixy was the only scanner tested that had a clear Open Source license, worked in the first place, and had both a reasonable recall and precision. Thus the decision was to build on Pixy for this thesis.



\section{Used Test Suite (READY FOR FEEDBACK)}
The author created a small test suite that was used to check the abilities of the various scanners. The test suite contains several instances of XSS and SQL injection in various forms:
\begin{itemize}
 \item source and sink within the same line
 \item source and sink on different lines within the same method
 \item source, sanitation and sink on different lines within the same method
 \item sanitation using PHP's built-in sanitation functions \texttt{mysql\_real\_escape\_string} and \texttt{intval}
 \item sanitation or source in other method in the same class
 \item sanitation or source in method of an instance of an included class
 \item sanitation or source in method in a static function of an included class
 \item sanitation or source in method in a static function of a class that is \emph{not} included, but expected to be autoloaded
\end{itemize}

The test suite includes the file listed below.



\subsection{Test.php}
\begin{phpcode}
require_once('IncludedGetter.php');

/**
 * This class contains various vulnerabilities to test some
 * vulnerability scanners.
 */
class Test {
  function get($key) {
    return $_GET[$key];
  }


  //////////////////
  // SQL injection
  //////////////////

  function sqlInjIntegerForSourceInline() {
    mysql_query('SELECT * FROM users WHERE id = ' . $_GET['id'] . ';');
  }

  function sqlInjIntegerForSourceInFunction() {
    $id = $_GET['id'];
    mysql_query('SELECT * FROM users WHERE id = ' . $id . ';');
  }

  function sqlInjIntegerForSourceInFunctionSanitizedInSource() {
    $id = intval($_GET['id']);
    mysql_query('SELECT * FROM users WHERE id = ' . $id . ';');
  }

  function sqlInjStringInFunctionSanitizedInSource() {
    $username = mysql_real_escape_string($_GET['username']);
    mysql_query('SELECT * FROM users WHERE username = "' .
    $username . '";');
  }

  function sqlInjIntegerForSourceInFunctionSanitizedInSink() {
    $id = $_GET['id'];
    mysql_query('SELECT * FROM users WHERE id = ' . intval($id) . ';');
  }
\end{phpcode}

\begin{phpcode}
  function sqlInjIntegerForSourceFromOtherFunctionInSameClass() {
    $id = $this->get('id');
    mysql_query('SELECT * FROM users WHERE id = ' . $id . ';');
  }

  function sqlInjIntegerForSourceInStaticFunctionInIncludedClass() {
    $id = IncludedGetter::staticGet('id');
    mysql_query('SELECT * FROM users WHERE id = ' . $id . ';');
  }

  function sqlInjIntegerForSourceFromInstanceOfIncludedClass() {
    $getter = new IncludedGetter();
    $id = $getter->get('id');
    mysql_query('SELECT * FROM users WHERE id = ' . $id . ';');
  }

  function sqlInjIntegerForSourceFromStaticFunctionInAutoloadedClass() {
    $id = AutoloadedGetter::staticGet('id');
    mysql_query('SELECT * FROM users WHERE id = ' . $id . ';');
  }

  function sqlInjIntegerForSourceFromInstanceOfAutoloadedClass() {
    $getter = new AutoloadedGetter();
    $id = $getter->get('id');
    mysql_query('SELECT * FROM users WHERE id = ' . $id . ';');
  }

  function sqlInjIntegerForSourceT3libDiv() {
    $id = t3lib_div::_GP('id');
    mysql_query('SELECT * FROM users WHERE id = ' . $id . ';');
  }

  function sqlInjIntegerInFunctionTypo3SanitizedInSource() {
    $id = t3lib_div::intval_positive($_GET['id']);
    mysql_query('SELECT * FROM users WHERE id = ' . $id . ';');
  }

  function sqlInjStringInFunctionTypo3SanitizedInSource() {
    $username = $GLOBALS['TYPO3_DB']
      ->fullQuoteStr($_GET['username'], 'users');
    mysql_query('SELECT * FROM users WHERE username = ' .
      $username . ';');
  }

  function sqlInjIntegerForSourceInFunctionAndTypo3Sink() {
    $GLOBALS['TYPO3_DB']->exec_SELECTquery('*', 'users', 'id = ' .
      $_GET['id'] . ';');
  }
\end{phpcode}

\begin{phpcode}
  /////////////////////////
  // Cross-site scripting
  /////////////////////////

  function xssForSourceInline() {
    echo 'Hello ' . $_GET['name'] . '!';
  }

  function xssForSourceInFunction() {
    $name = $_GET['name'];
    echo 'Hello ' . $name . '!';
  }

  function xssForSourceInFunctionSanitizedInSource() {
    $name = htmlspecialchars($_GET['name']);
    echo 'Hello ' . $name . '!';
  }

  function xssForSourceInFunctionSanitizedInSink() {
    $name = $_GET['name'];
    echo 'Hello ' . htmlspecialchars($name) . '!';
  }

  function xssForSourceFromOtherFunctionInSameClass() {
    $name = $this->get('name');
    echo 'Hello ' . $name . '!';
  }

  function xssForSourceFromStaticFunctionInIncludedClass() {
    $name = IncludedGetter::staticGet('name');
    echo 'Hello ' . $name . '!';
  }

  function xssForSourceFromInstanceOfIncludedClass() {
    $getter = new IncludedGetter();
    $name = $getter->get('name');
    echo 'Hello ' . $name . '!';
  }

  function xssForSourceFromStaticFunctionInAutoloadedClass() {
    $name = AutoloadedGetter::staticGet('name');
    echo 'Hello ' . $name . '!';
  }
\end{phpcode}

\begin{phpcode}
  function xssForSourceFromInstanceOfAutoloadedClass() {
    $getter = new AutoloadedGetter();
    $name = $getter->get('name');
    echo 'Hello ' . $name . '!';
  }

  function xssForSourceT3libDiv() {
    $name = t3lib_div::_GP('name');
    echo 'Hello ' . $name . '!';
  }

  function xssForSourceInFunctionTypo3SanitizedInSource() {
    $name = t3lib_div::removeXSS($_GET['name']);
    echo 'Hello ' . $name . '!';
  }
}
\end{phpcode}

\begin{phpcode}
$test = new Test();
$test->sqlInjIntegerForSourceInline();
$test->sqlInjIntegerForSourceInFunction();
$test->sqlInjIntegerForSourceInFunctionSanitizedInSource();
$test->sqlInjStringInFunctionSanitizedInSource();
$test->sqlInjIntegerForSourceInFunctionSanitizedInSink();
$test->sqlInjIntegerForSourceFromOtherFunctionInSameClass();
$test->sqlInjIntegerForSourceFromStaticFunctionInIncludedClass();
$test->sqlInjIntegerForSourceFromInstanceOfIncludedClass();
$test->sqlInjIntegerForSourceFromStaticFunctionInAutoloadedClass();
$test->sqlInjIntegerForSourceFromInstanceOfAutoloadedClass();
$test->sqlInjIntegerForSourceT3libDiv();
$test->sqlInjIntegerInFunctionTypo3SanitizedInSource();
$test->sqlInjStringInFunctionTypo3SanitizedInSource();
$test->sqlInjIntegerForSourceInFunctionAndTypo3Sink();
$test->xssForSourceInline();
$test->xssForSourceInFunction();
$test->xssForSourceInFunctionSanitizedInSource();
$test->xssForSourceInFunctionSanitizedInSink();
$test->xssForSourceFromOtherFunctionInSameClass();
$test->xssForSourceFromStaticFunctionInIncludedClass();
$test->xssForSourceFromInstanceOfIncludedClass();
$test->xssForSourceFromStaticFunctionInAutoloadedClass();
$test->xssForSourceFromInstanceOfAutoloadedClass();
$test->xssForSourceT3libDiv();
$test->xssForSourceInFunctionTypo3SanitizedInSource();
\end{phpcode}
\normalsize



\subsection{IncludedGetter.php}
\small
\begin{phpcode}
/**
 * This class contains two wrappers for _GET and is included by the
 * main Test class.
 */
class IncludedGetter {
  function staticGet($key) {
    return $_GET[$key];
  }

  function get($key) {
    return $_GET[$key];
  }
}
\end{phpcode}
\normalsize




\subsection{AutoloadedGetter.php}
\small
\begin{phpcode}
/**
 * This class contains two wrappers for _GET and is _not_ included by
 * the main Test class, but could be autoloaded.
 */
class AutoloadedGetter {
  function staticGet($key) {
    return $_GET[$key];
  }

  function get($key) {
    return $_GET[$key];
  }
}
\end{phpcode}
\normalsize



\subsection{ClassTest.php}
\small
\begin{phpcode}
class Foo {
  function unsafeSource() {
    return $_GET['number'];
  }

  function safeSource() {
    return intval($_GET['number']);
  }

  function unsafeSink($number) {
    echo($number);
  }

  function safeSink($number) {
    echo(intval($number));
  }

  function doItDoubleSafely() {
    $this->safeSink($this->safeSource());
  }

  function doItWithSafeSink() {
    $this->safeSink($this->unsafeSource());
  }

  function doItWithSafeSource() {
    $this->unsafeSink($this->safeSource());
  }

  function doItCompletelyUnsafe() {
    $this->unsafeSink($this->unsafeSource());
  }
}
\end{phpcode}

\begin{phpcode}
class EmptyFoo extends Foo {
  function safeSink($number) {
    echo($number);
  }

  function safeSource() {
    return $_GET['number'];
  }
  function doItCompletelyUnsafe() {
    $this->unsafeSink($this->unsafeSource());
  }
}
\end{phpcode}

\begin{phpcode}
$foo = new Foo();

echo($foo->safeSource());
echo($foo->unsafeSource());
echo(Foo::unsafeSource());

$foo->safeSink($_GET['number']);
$foo->safeSink(intval($_GET['number']));

$foo->unsafeSink($_GET['number']);
Foo::unsafeSink($_GET['number']);
$foo->unsafeSink(intval($_GET['number']));

$foo->safeSink($foo->safeSource());
$foo->safeSink($foo->unsafeSource());
Foo::safeSink(Foo::unsafeSource());

$foo->unsafeSink($foo->safeSource());
Foo::unsafeSink(Foo::safeSource());
$foo->unsafeSink($foo->unsafeSource());
Foo::unsafeSink(Foo::unsafeSource());

$foo->doItDoubleSafely();
$foo->doItWithSafeSink();
$foo->doItWithSafeSource();

$foo->doItCompletelyUnsafe();

$emptyFoo = new Foo();
$emptyFoo->doItCompletelyUnsafe();
$emptyFoo->doItDoubleSafely();
$emptyFoo->safeSink($emptyFoo->safeSource());
\end{phpcode}
\normalsize



\subsection{PassByReference.php}
\small
\begin{phpcode}
class Foo {
  var $someProperty = '';
}

function modifyProperty($object, $propertyContent) {
  $object->someProperty = $propertyContent;
}

$object = new Foo();
modifyProperty($object, $_GET['name']);

echo $object->someProperty;
\end{phpcode}
\normalsize

